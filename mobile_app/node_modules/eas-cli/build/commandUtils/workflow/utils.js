"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processLogsFromJobAsync = exports.processWorkflowRuns = exports.choicesFromWorkflowLogs = exports.choiceFromWorkflowJob = exports.choiceFromWorkflowRun = exports.computeTriggerInfoForWorkflowRun = void 0;
const fetchLogs_1 = require("./fetchLogs");
const types_1 = require("./types");
const generated_1 = require("../../graphql/generated");
function computeTriggerInfoForWorkflowRun(run) {
    let triggerType = types_1.WorkflowTriggerType.OTHER;
    let trigger = '';
    if (run.actor?.__typename === 'Robot') {
        if (run.actor.firstName?.startsWith('GitHub App Â· ')) {
            trigger = `${run.requestedGitRef ?? ''}@${run.gitCommitHash?.substring(0, 12) ?? ''}`;
        }
    }
    else if (run.actor?.__typename === 'User') {
        trigger = run.actor.username;
    }
    switch (run.triggerEventType) {
        case generated_1.WorkflowRunTriggerEventType.Manual:
            triggerType = types_1.WorkflowTriggerType.MANUAL;
            break;
        case generated_1.WorkflowRunTriggerEventType.GithubPullRequestLabeled:
        case generated_1.WorkflowRunTriggerEventType.GithubPullRequestOpened:
        case generated_1.WorkflowRunTriggerEventType.GithubPullRequestReopened:
        case generated_1.WorkflowRunTriggerEventType.GithubPullRequestSynchronize:
        case generated_1.WorkflowRunTriggerEventType.GithubPush:
            triggerType = types_1.WorkflowTriggerType.GITHUB;
            break;
        case generated_1.WorkflowRunTriggerEventType.Schedule:
            triggerType = types_1.WorkflowTriggerType.SCHEDULED;
            trigger = run.triggeringSchedule ?? '';
            break;
    }
    return { triggerType, trigger };
}
exports.computeTriggerInfoForWorkflowRun = computeTriggerInfoForWorkflowRun;
function choiceFromWorkflowRun(run) {
    const titleArray = [
        run.workflowFileName,
        run.status,
        run.startedAt,
        run.triggerType,
        run.trigger,
    ];
    return {
        title: titleArray.join(' - '),
        value: run.id,
        description: `ID: ${run.id}, Message: ${run.gitCommitMessage?.split('\n')[0] ?? ''}`,
    };
}
exports.choiceFromWorkflowRun = choiceFromWorkflowRun;
function choiceFromWorkflowJob(job, index) {
    return {
        title: `${job.name} - ${job.status}`,
        value: index,
        description: `ID: ${job.id}`,
    };
}
exports.choiceFromWorkflowJob = choiceFromWorkflowJob;
function choicesFromWorkflowLogs(logs) {
    return Array.from(logs.keys()).map(step => {
        const logLines = logs.get(step);
        const stepStatus = logLines?.filter((line) => line.marker === 'end-step')[0]?.result ?? '';
        return {
            title: `${step} - ${stepStatus}`,
            value: step,
        };
    });
}
exports.choicesFromWorkflowLogs = choicesFromWorkflowLogs;
function processWorkflowRuns(runs) {
    return runs.map(run => {
        const finishedAt = run.status === generated_1.WorkflowRunStatus.InProgress ? null : run.updatedAt;
        const { triggerType, trigger } = computeTriggerInfoForWorkflowRun(run);
        return {
            id: run.id,
            status: run.status,
            gitCommitMessage: run.gitCommitMessage?.split('\n')[0] ?? null,
            gitCommitHash: run.gitCommitHash ?? null,
            startedAt: run.createdAt,
            finishedAt,
            triggerType,
            trigger,
            workflowId: run.workflow.id,
            workflowName: run.workflow.name ?? null,
            workflowFileName: run.workflow.fileName,
        };
    });
}
exports.processWorkflowRuns = processWorkflowRuns;
async function processLogsFromJobAsync(job) {
    const rawLogs = await (0, fetchLogs_1.fetchRawLogsForJobAsync)(job);
    if (!rawLogs) {
        return null;
    }
    const logs = new Map();
    const logKeys = new Set();
    rawLogs.split('\n').forEach(line => {
        try {
            const parsedLine = JSON.parse(line);
            const { result, marker } = parsedLine;
            const { buildStepDisplayName, buildStepInternalId, time, msg } = parsedLine;
            const stepId = buildStepDisplayName ?? buildStepInternalId;
            if (stepId) {
                if (!logKeys.has(stepId)) {
                    logKeys.add(stepId);
                    logs.set(stepId, []);
                }
                logs.get(stepId)?.push({ time, msg, result, marker });
            }
        }
        catch { }
    });
    return logs;
}
exports.processLogsFromJobAsync = processLogsFromJobAsync;
