"use strict";
/**
 * EAS Workflow Run Command
 *
 * This command runs an EAS workflow with support for interactive input prompting.
 *
 * Input Sources (in order of precedence):
 * 1. Command line flags (-F key=value)
 * 2. STDIN JSON input (echo '{"key": "value"}' | eas workflow:run)
 * 3. Interactive prompts (when required inputs are missing and not in non-interactive mode)
 *
 * Interactive Prompting:
 * - When running in interactive mode (default), the command will automatically prompt
 *   for any required inputs that are not provided via flags or STDIN
 * - Input types supported: string, boolean, number, choice, environment
 * - Each input type has appropriate validation and default values
 * - Use --non-interactive flag to disable prompting and require all inputs via flags
 *
 * Example workflow with inputs:
 * ```yaml
 * on:
 *   workflow_dispatch:
 *     inputs:
 *       environment:
 *         type: string
 *         required: true
 *         description: "Environment to deploy to"
 *       debug:
 *         type: boolean
 *         default: false
 *         description: "Enable debug mode"
 *       version:
 *         type: number
 *         required: true
 *         description: "Version number"
 *       deployment_type:
 *         type: choice
 *         options: ["staging", "production"]
 *         default: "staging"
 *         description: "Type of deployment"
 * ```
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseWorkflowInputsFromYaml = exports.WorkflowDispatchInputZ = exports.parseJsonInputs = exports.maybeReadStdinAsync = exports.parseInputs = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const core_2 = require("@urql/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs = tslib_1.__importStar(require("node:fs"));
const path = tslib_1.__importStar(require("node:path"));
const slash_1 = tslib_1.__importDefault(require("slash"));
const YAML = tslib_1.__importStar(require("yaml"));
const zod_1 = require("zod");
const url_1 = require("../../build/utils/url");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const generated_1 = require("../../graphql/generated");
const WorkflowRevisionMutation_1 = require("../../graphql/mutations/WorkflowRevisionMutation");
const WorkflowRunMutation_1 = require("../../graphql/mutations/WorkflowRunMutation");
const WorkflowRunQuery_1 = require("../../graphql/queries/WorkflowRunQuery");
const log_1 = tslib_1.__importStar(require("../../log"));
const ora_1 = require("../../ora");
const projectUtils_1 = require("../../project/projectUtils");
const uploadAccountScopedFileAsync_1 = require("../../project/uploadAccountScopedFileAsync");
const uploadAccountScopedProjectSourceAsync_1 = require("../../project/uploadAccountScopedProjectSourceAsync");
const prompts_1 = require("../../prompts");
const json_1 = require("../../utils/json");
const promise_1 = require("../../utils/promise");
const workflowFile_1 = require("../../utils/workflowFile");
const EXIT_CODES = {
    WORKFLOW_FAILED: 11,
    WORKFLOW_CANCELED: 12,
    WAIT_ABORTED: 13,
};
class WorkflowRun extends EasCommand_1.default {
    static description = 'run an EAS workflow';
    static args = [{ name: 'file', description: 'Path to the workflow file to run' }];
    static flags = {
        ...flags_1.EASNonInteractiveFlag,
        wait: core_1.Flags.boolean({
            default: false,
            allowNo: true,
            description: 'Exit codes: 0 = success, 11 = failure, 12 = canceled, 13 = wait aborted.',
            summary: 'Wait for workflow run to complete',
        }),
        input: core_1.Flags.string({
            char: 'F',
            aliases: ['f', 'field'],
            multiple: true,
            description: 'Add a parameter in key=value format. Use multiple instances of this flag to set multiple inputs.',
            summary: 'Set workflow inputs',
        }),
        ...flags_1.EasJsonOnlyFlag,
    };
    static contextDefinition = {
        ...this.ContextOptions.DynamicProjectConfig,
        ...this.ContextOptions.ProjectDir,
        ...this.ContextOptions.Vcs,
        ...this.ContextOptions.LoggedIn,
    };
    async runAsync() {
        const { flags, args } = await this.parse(WorkflowRun);
        if (flags.json) {
            (0, json_1.enableJsonOutput)();
        }
        const { getDynamicPrivateProjectConfigAsync, loggedIn: { graphqlClient }, vcsClient, projectDir, } = await this.getContextAsync(WorkflowRun, {
            nonInteractive: flags['non-interactive'],
            withServerSideEnvironment: null,
        });
        let yamlConfig;
        try {
            const workflowFileContents = await workflowFile_1.WorkflowFile.readWorkflowFileContentsAsync({
                projectDir,
                filePath: args.file,
            });
            log_1.default.log(`Using workflow file from ${workflowFileContents.filePath}`);
            yamlConfig = workflowFileContents.yamlConfig;
        }
        catch (err) {
            log_1.default.error('Failed to read workflow file.');
            throw err;
        }
        const { projectId, exp: { slug: projectName }, } = await getDynamicPrivateProjectConfigAsync();
        const account = await (0, projectUtils_1.getOwnerAccountForProjectIdAsync)(graphqlClient, projectId);
        try {
            await WorkflowRevisionMutation_1.WorkflowRevisionMutation.validateWorkflowYamlConfigAsync(graphqlClient, {
                appId: projectId,
                yamlConfig,
            });
        }
        catch (error) {
            if (error instanceof core_2.CombinedError) {
                workflowFile_1.WorkflowFile.maybePrintWorkflowFileValidationErrors({
                    error,
                    accountName: account.name,
                    projectName,
                });
                throw error;
            }
        }
        let inputs;
        // Check for stdin input
        const stdinData = await maybeReadStdinAsync();
        const inputsFromFlags = [...(flags.input ?? [])];
        // Validate that both stdin and -F flags are not provided simultaneously
        if (stdinData && inputsFromFlags.length > 0) {
            throw new Error('Cannot use both stdin JSON input and -F flags simultaneously. Please use only one input method.');
        }
        if (stdinData) {
            inputs = parseJsonInputs(stdinData);
        }
        else if (inputsFromFlags.length > 0) {
            inputs = parseInputs(inputsFromFlags);
        }
        // Parse workflow inputs from YAML and prompt for missing required inputs
        const inputSpecs = parseWorkflowInputsFromYaml(yamlConfig);
        if (!flags['non-interactive']) {
            inputs = await maybePromptForMissingInputsAsync({ inputSpecs, inputs: inputs ?? {} });
        }
        if (inputs && Object.keys(inputs).length > 0) {
            log_1.default.addNewLineIfNone();
            log_1.default.newLine();
            log_1.default.log('Running with inputs:');
            for (const [key, value] of Object.entries(inputs)) {
                log_1.default.log(`- ${chalk_1.default.bold(key)}: ${JSON.stringify(value)}`);
            }
        }
        let projectArchiveBucketKey;
        let easJsonBucketKey = null;
        let packageJsonBucketKey = null;
        const easJsonPath = path.join(projectDir, 'eas.json');
        const packageJsonPath = path.join(projectDir, 'package.json');
        const projectRootDirectory = (0, slash_1.default)(path.relative(await vcsClient.getRootPathAsync(), projectDir) || '.');
        try {
            ({ projectArchiveBucketKey } = await (0, uploadAccountScopedProjectSourceAsync_1.uploadAccountScopedProjectSourceAsync)({
                graphqlClient,
                vcsClient,
                accountId: account.id,
            }));
            if (await fileExistsAsync(easJsonPath)) {
                ({ fileBucketKey: easJsonBucketKey } = await (0, uploadAccountScopedFileAsync_1.uploadAccountScopedFileAsync)({
                    graphqlClient,
                    accountId: account.id,
                    filePath: easJsonPath,
                    maxSizeBytes: 1024 * 1024,
                }));
            }
            else {
                log_1.default.warn(`⚠ No ${chalk_1.default.bold('eas.json')} found in the project directory. Running ${chalk_1.default.bold('type: build')} jobs will not work. Run ${chalk_1.default.bold('eas build:configure')} to configure your project for builds.`);
            }
            if (await fileExistsAsync(packageJsonPath)) {
                ({ fileBucketKey: packageJsonBucketKey } = await (0, uploadAccountScopedFileAsync_1.uploadAccountScopedFileAsync)({
                    graphqlClient,
                    accountId: account.id,
                    filePath: packageJsonPath,
                    maxSizeBytes: 1024 * 1024,
                }));
            }
            else {
                log_1.default.warn(`⚠ No ${chalk_1.default.bold('package.json')} found in the project directory. It is used to automatically infer best job configuration for your project. You may want to define ${chalk_1.default.bold('image')} property in your workflow to specify the image to use.`);
            }
        }
        catch (err) {
            log_1.default.error('Failed to upload project sources.');
            throw err;
        }
        let workflowRunId;
        try {
            ({ id: workflowRunId } = await WorkflowRunMutation_1.WorkflowRunMutation.createWorkflowRunAsync(graphqlClient, {
                appId: projectId,
                workflowRevisionInput: {
                    fileName: path.basename(args.file),
                    yamlConfig,
                },
                workflowRunInput: {
                    inputs,
                    projectSource: {
                        type: generated_1.WorkflowProjectSourceType.Gcs,
                        projectArchiveBucketKey,
                        easJsonBucketKey,
                        packageJsonBucketKey,
                        projectRootDirectory,
                    },
                },
            }));
            log_1.default.newLine();
            log_1.default.log(`See logs: ${(0, log_1.link)((0, url_1.getWorkflowRunUrl)(account.name, projectName, workflowRunId))}`);
        }
        catch (err) {
            log_1.default.error('Failed to start the workflow with the API.');
            throw err;
        }
        if (!flags.wait) {
            if (flags.json) {
                (0, json_1.printJsonOnlyOutput)({
                    id: workflowRunId,
                    url: (0, url_1.getWorkflowRunUrl)(account.name, projectName, workflowRunId),
                });
            }
            process.exit(0);
        }
        log_1.default.newLine();
        const { status } = await waitForWorkflowRunToEndAsync(graphqlClient, {
            workflowRunId,
        });
        if (flags.json) {
            const workflowRun = await WorkflowRunQuery_1.WorkflowRunQuery.withJobsByIdAsync(graphqlClient, workflowRunId, {
                useCache: false,
            });
            (0, json_1.printJsonOnlyOutput)({
                ...workflowRun,
                url: (0, url_1.getWorkflowRunUrl)(account.name, projectName, workflowRunId),
            });
        }
        if (status === generated_1.WorkflowRunStatus.Failure) {
            process.exit(EXIT_CODES.WORKFLOW_FAILED);
        }
        else if (status === generated_1.WorkflowRunStatus.Canceled) {
            process.exit(EXIT_CODES.WORKFLOW_CANCELED);
        }
    }
}
exports.default = WorkflowRun;
async function waitForWorkflowRunToEndAsync(graphqlClient, { workflowRunId }) {
    log_1.default.log('Waiting for workflow run to complete. You can press Ctrl+C to exit.');
    const spinner = (0, ora_1.ora)('Currently waiting for workflow run to start.').start();
    let failedFetchesCount = 0;
    while (true) {
        try {
            const workflowRun = await WorkflowRunQuery_1.WorkflowRunQuery.byIdAsync(graphqlClient, workflowRunId, {
                useCache: false,
            });
            failedFetchesCount = 0;
            switch (workflowRun.status) {
                case generated_1.WorkflowRunStatus.InProgress:
                    spinner.start('Workflow run is in progress.');
                    break;
                case generated_1.WorkflowRunStatus.ActionRequired:
                    spinner.warn('Workflow run is waiting for action.');
                    break;
                case generated_1.WorkflowRunStatus.Canceled:
                    spinner.warn('Workflow run has been canceled.');
                    return workflowRun;
                case generated_1.WorkflowRunStatus.Failure:
                    spinner.fail('Workflow run has failed.');
                    return workflowRun;
                case generated_1.WorkflowRunStatus.Success:
                    spinner.succeed('Workflow run completed successfully.');
                    return workflowRun;
            }
        }
        catch {
            spinner.text = '⚠ Failed to fetch the workflow run status. Check your network connection.';
            failedFetchesCount += 1;
            if (failedFetchesCount > 6) {
                spinner.fail('Failed to fetch the workflow run status 6 times in a row. Aborting wait.');
                process.exit(EXIT_CODES.WAIT_ABORTED);
            }
        }
        await (0, promise_1.sleepAsync)(10 /* seconds */ * 1000 /* milliseconds */);
    }
}
async function fileExistsAsync(filePath) {
    return await fs.promises
        .access(filePath, fs.constants.F_OK)
        .then(() => true)
        .catch(() => false);
}
function parseInputs(inputFlags) {
    const inputs = {};
    for (const inputFlag of inputFlags) {
        const equalIndex = inputFlag.indexOf('=');
        if (equalIndex === -1) {
            throw new Error(`Invalid input format: ${inputFlag}. Expected key=value format.`);
        }
        const key = inputFlag.substring(0, equalIndex);
        const value = inputFlag.substring(equalIndex + 1);
        if (!key) {
            throw new Error(`Invalid input format: ${inputFlag}. Key cannot be empty.`);
        }
        inputs[key] = value;
    }
    return inputs;
}
exports.parseInputs = parseInputs;
async function maybeReadStdinAsync() {
    // Check if there's data on stdin
    if (process.stdin.isTTY) {
        return null;
    }
    return await new Promise((resolve, reject) => {
        let data = '';
        process.stdin.setEncoding('utf8');
        process.stdin.on('readable', () => {
            let chunk;
            while ((chunk = process.stdin.read()) !== null) {
                data += chunk;
            }
        });
        process.stdin.on('end', () => {
            const trimmedData = data.trim();
            resolve(trimmedData || null);
        });
        process.stdin.on('error', err => {
            reject(err);
        });
    });
}
exports.maybeReadStdinAsync = maybeReadStdinAsync;
function parseJsonInputs(jsonString) {
    try {
        const parsed = JSON.parse(jsonString);
        if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) {
            throw new Error('JSON input must be an object.');
        }
        return parsed;
    }
    catch (error) {
        throw new Error(`Invalid JSON input.`, { cause: error });
    }
}
exports.parseJsonInputs = parseJsonInputs;
// `z.coerce.boolean()` does `Boolean(val)` under the hood,
// which is not what we want. See:
// https://github.com/colinhacks/zod/issues/2985#issuecomment-2230692578
const booleanLike = zod_1.z.union([
    zod_1.z.boolean(),
    zod_1.z.codec(zod_1.z.number(), zod_1.z.boolean(), {
        decode: n => !!n,
        encode: b => (b ? 1 : 0),
    }),
    zod_1.z.stringbool({ truthy: ['true', 'True'], falsy: ['false', 'False'] }),
]);
const stringLike = zod_1.z.codec(zod_1.z.union([
    // We're going to coerce numbers and strings into strings.
    zod_1.z.number(),
    zod_1.z.string(),
    // We do not allow other primitives, like:
    // - bigints, symbols - because YAML does not support them,
    // - booleans - because YAML accepts `True` and `true` as boolean input
    //   and parses both as JS `true` -- if we stringified that,
    //   we would lose the capital "T" which may not be what the user expects,
    // - nulls - user should do `"null"` or not pass the property at all.
]), zod_1.z.string(), {
    decode: value => {
        if (typeof value === 'string') {
            return value;
        }
        if (typeof value === 'number') {
            return String(value);
        }
        throw new Error(`Cannot convert ${typeof value} to string: ${value}`);
    },
    encode: value => value,
});
exports.WorkflowDispatchInputZ = zod_1.z
    .object({
    description: stringLike.optional().describe('Description of the input'),
    required: booleanLike.default(false).describe('Whether the input is required.'),
})
    .and(zod_1.z.union([
    zod_1.z.object({
        type: zod_1.z.literal('string').default('string'),
        default: stringLike.optional().describe('Default value for the input'),
    }),
    zod_1.z.object({
        type: zod_1.z.literal('boolean'),
        default: booleanLike.optional().describe('Default value for the input'),
    }),
    zod_1.z.object({
        type: zod_1.z.literal('number'),
        default: zod_1.z.number().optional().describe('Default value for the input'),
    }),
    zod_1.z.object({
        type: zod_1.z.literal('choice'),
        default: stringLike.optional().describe('Default value for the input'),
        options: zod_1.z.array(stringLike).min(1).describe('Options for choice type inputs'),
    }),
    zod_1.z.object({
        type: zod_1.z.literal('environment'),
        default: zod_1.z.string().optional().describe('Default value for the input'),
    }),
]));
function parseWorkflowInputsFromYaml(yamlConfig) {
    try {
        const parsed = YAML.parse(yamlConfig);
        return zod_1.z
            .record(zod_1.z.string(), exports.WorkflowDispatchInputZ)
            .default({})
            .parse(parsed?.on?.workflow_dispatch?.inputs);
    }
    catch (error) {
        log_1.default.warn('Failed to parse workflow inputs from YAML:', error);
        return {};
    }
}
exports.parseWorkflowInputsFromYaml = parseWorkflowInputsFromYaml;
async function maybePromptForMissingInputsAsync({ inputSpecs, inputs, }) {
    const requiredInputs = Object.entries(inputSpecs).filter(([_, spec]) => spec.required);
    const missingRequiredInputs = requiredInputs.filter(([key]) => inputs[key] === undefined);
    if (missingRequiredInputs.length === 0) {
        return inputs;
    }
    log_1.default.addNewLineIfNone();
    log_1.default.log('Some required inputs are missing. Please provide them:');
    const nextInputs = { ...inputs };
    for (const [key, spec] of missingRequiredInputs) {
        const value = await promptForMissingInputAsync({ key, spec });
        nextInputs[key] = value;
    }
    return nextInputs;
}
async function promptForMissingInputAsync({ key, spec, }) {
    const message = spec.description ? `${key} (${spec.description})` : key;
    switch (spec.type) {
        case 'boolean': {
            const { value } = await (0, prompts_1.promptAsync)({
                type: 'confirm',
                name: 'value',
                message,
                initial: spec.default,
            });
            return value;
        }
        case 'number': {
            const { value } = await (0, prompts_1.promptAsync)({
                type: 'number',
                name: 'value',
                message,
                initial: spec.default,
                validate: (val) => {
                    if (isNaN(val)) {
                        return 'Please enter a valid number';
                    }
                    return true;
                },
            });
            return value;
        }
        case 'choice': {
            const { value } = await (0, prompts_1.promptAsync)({
                type: 'select',
                name: 'value',
                message,
                choices: spec.options.map(option => ({
                    title: option,
                    value: option,
                })),
                initial: spec.default,
            });
            return value;
        }
        case 'string':
        case 'environment': {
            const { value } = await (0, prompts_1.promptAsync)({
                type: 'text',
                name: 'value',
                message,
                initial: spec.default,
                validate: (val) => {
                    if (spec.required && (!val || val.trim() === '')) {
                        return 'This field is required';
                    }
                    return true;
                },
            });
            return value;
        }
    }
}
